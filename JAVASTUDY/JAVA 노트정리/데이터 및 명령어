컴퓨터 구조를 알아야 하는 이유
 문제해결 능력을 기를 수 있고, 성능, 용량, 비용을 고려한 개발을 할 수 있기 때문이다.

 문제 해결 능력 -> 컴퓨터 구조를 이해하고 있다면 컴퓨터를 미지의 대상이 아니라 분석의 대상으로 인식, 컴퓨터 내부를 거리낌 없이 들여다보고 더 좋은 해결책을 고민 하게 되기 때문이다.(컴퓨터를 내려다보며 문제를 해결할 수 있는 개발자가 될 수 있다.)

 성능, 용량, 비용 -> 서버 컴퓨터를 구매하거나 클라우드 서비스를 이용할 때, 어떤 CPU를 사용할지, 어떤 메모리를 사용할지 등을 직접 판단하고 현명하게 선택을 해야하기 때문에 컴퓨터 구조를 이해하면 입력과 출력에만 집중하는 개발을 넘어 성능,용량,비용까지 고려하며 개발하는 개발자가 될 수 있다.

컴퓨터 구조의 큰 그림
○ 컴퓨터 구조
 - 컴퓨터가 이해하는 정보

  - 데이터
   - 숫자, 문자, 이미지, 동영상 같은 정적인 정보를 의미
   - 컴퓨터와 주고 받는/내부에 저장된 정보를 데이터라 통칭
   - 0과 1로 숫자 및 문자를 표현하는 방법

  - 명령어
   - 컴퓨터를 실질적으로 움직이는 정보
   - 데이터는 명령어를 위한 일종의 재료

 - 컴퓨터의 네 가지 핵심 부품
  - CPU
   - CPU 내부에는 ALU, 레지스터, 제어장치가 있다.
    - 산술논리연산장치(ALU) : 계산기(계산하는 장치)
    - 레지스터 : CPU 내부의 임시 저장 장치
    - 제어장치 : 제어 신호를 내보내고, 명령어를 해석하는 장치
     - 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호
       - 메모리 읽기신호 : CPU가 메모리에 저장된 값을 읽고 싶을 때 메모리를 향해 보내는 전기 신호
       - 메모리 쓰기신호 : CUP가 메모리에 어떤 값을 저장하고 싶을 때 메모리를 향해 보내는 전기 신호


  - 메모리(주기억장치 -main memory)
   - RAM,ROM이 있지만 일반적으로 메모리는 RAM을 지칭한다.
   - 프로그램이 실행되기 위해서는 메모리에 저장
   - 현재 실행되는 프로그램의 명령어와 데이터를 저장
   - 메모리는 저장된 값에 빠르고 효율적으로 접근하기 위해 주소라는 개념을 사용
     (메모리에 저장된 값의 위치는 주소로 알 수 있다.)

  - 보조기억장치
   - 메모리는 실행할 정보를 저장하고, 보조기억장치는 보관할 정보를 저장
     (보조기억장치는 전원이 꺼져도 저장된 내용을 보관 할 수 있다. - SSD, USB, DVD, CD-ROM 등)

  - 입출력장치
   - 컴퓨터 외부에 연결이 돼서 컴퓨터 내부와 정보를 주고 받을 수 있는 컴퓨터 부품
   - 마이크, 스피커, 프린터, 마우스, 키보드처럼 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치

  - 메인보드
   - 여러 컴퓨터 부품을 연결할 수 있는 판(메인보드)
   - 메인보드에 연결된 부품은 버스를 통해 정보를 주고 받음
   - 부품끼리 정보를 주고 받을 수 있는 통로(버스)
   - 다양한 종류의 버스가 있음
   - 네 가지 핵심 부품을 연결하는 가장 중요한 버스(시스템버스)

  - 시스템버스
   - 주소 버스 : 주소를 주고받는 통로
   - 데이터 버스 : 명령어와 데이터를 주고받는 통로
   - 제어 버스 : 제어 신호를 주고받는 통로


데이터

0과 1로 숫자를 표현하는 방법

 - 정보 단위
  - 비트(bit) : 0과 1을 표현하는 가장 작은 정보 단위
1바이트(1byte)	8비트(8bit)
1킬로바이트(1kB)	1000바이트(1000byte)
1메가바이트(1MB)	1000킬로바이트(1000kB)
1기가바이트(1GB)	1000메가바이트(1000MB)
1테라바이트(1TB)	1000기가바이트(1000GB)

  - 워드(word) : CPU가 한 번에 처리할 수 있는 정보의 크기 단위
   - 하프 워드(half word) : 워드의 절반 크기
   - 풀 워드(full word) : 워드 크기
   - 더블 워드(double word) : 워드의 두 배 크기

 - 이진법(binary)
  - 0과 1로 수를 표현하는 방법
  - 숫자가 1을 넘어가는 시점에 자리 올림
  - 우리가 일상적으로 사용하는 진법은 숫자가 9를 넘어갈 때 자리올림하는 십진법(decimal)
  - 0과 1로 음수 표현하기 : 2의 보수
   - 사전적 의미 : 어떤 수를 그보다 큰 2n에서 뺀 값
   - 쉽게 표현한 의미 : 모든 0과 1을 뒤집고 1을 더한 값

 - 십육진법
  - 이진법으로는 숫자의 길이가 너무 길어져서 사용
   - 십진수 32 == 이진수 100000
  - 그래서 컴퓨터의 데이터를 표현할 때 십육진법도 많이 사용
   - 수가 15를 넘어가는 시점에서 자리올림
  - 2진법으로 변환하기
  - 이진수 숫자를 네 개씩 끊고, 끊어 준 네 개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어 붙이면 됨(변환이 매우 쉽고 길이가 짧아져서 많이 사용)
     => 1A2B16 == 00011010001010112






0과 1로 문자를 표현하는 방법

 - 문자 집합과 인코딩
  - 문자 집합(character set)
   - 컴퓨터가 이해할 수 있는 문자의 모음

  - 인코딩(encoding)
   - 코드화하는 과정
   - 문자를 0과 1로 이루어진 문자 코드로 변환하는 과정

  - 디코딩(decoding)
   - 코드를 해석하는 과정
   - 0과 1로 표현된 문자 코드로 문자로 변환하는 과정

  - 아스키 코드
   - 초창기 문자 집합 중 하나
   - 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자
   - 7비트로 하나의 문자 표현
    - 8비트 중 1비트는 오류 검출을 위해 사용되는 패리티 비트(parity bit)
    - 7비트로 표현할 수 있는 정보의 가짓수는 27 개로, 총 128개의 문자를 표현
   - 간단한 인코딩
   - 하지만 한글을 포함한 다른 언어 문자, 다양한 특수 문자 표현 불가
   - 아스키 코드는 7비트로 하나의 문자를 표현하기에 128개보다 많은 문자를 표현할 수 없음
   - 8비트 확장 아스키(exteded ASCII)의 등장, 여전히 부족

  - 한글 인코딩(EUC-KR)
   - 한글은 각 음절 하나하나가 초성,중성,종성의 조합으로 이루어져 있어, 한글 인코딩에는 두 가지 방식의 인코딩이 존재
   - EUC-KR은 KS X 1001, KS X 1003이라는 문자 집합을 기반으로 하는 대표적인 완성형 인코딩 방식
   - 완성형 인코딩
    - 초성,중성,종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 인코딩 방식
   - 조합형 인코딩
    - 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식
  - 하지만 EUC-KR은 2300여개의 한글 표현이 가능하지만 여전히 모든 한글을 표현하기에는 부족한 수
  - EUC-KR은 언어별로 인코딩을 국가마다 해야하기 때문에 다국어를 지원하는 프로그램을 개발할 때엔 언어별로인코딩 방식을 모두 이해해야 함

 - 유니코드 문자 집합과 UTF-8
  - 유니코드
   - 통일된 문자 집합
   - 한글, 영어, 화살표와 같은 특수 문자, 심지어 이모티콘까지
   - 현대 문자 표현할 때 가장 많이 사용되는 표준 문자집합이며, 문자 인코딩 세계에서 매우 중요한 역할을 맡음
   - 유니코드는 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 이 값을 다양한 방법으로 인코딩(UTF-8, UTF-16, UTF-32 등)

  - UTF-8(Unicode Transformation Format)
   - 가변 길이 인코딩 : 1바이트부터 4바이트까지의 인코딩 결과를 만들어 냄
   - 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값에 따라 다름

명령어

소스 코드와 명령어

 - 고급언어
  - 개발자가 이해하기 쉽게 만든 언어
  - C언어, C++, Java, Python과 같은 프로그래밍 언어
 - 저급언어
  - 컴퓨터가 이해하고 실행하는 언어
  - 기계어
   - 0과 1의 명령어 비트로 이루어진 언어
  - 어쎔블리어
   - 0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 언어
 - 고급언어가 저급언어로 변환되는 방식
  - 컴파일언어
   - 소스 코드 전체가 저급 언어로 별환
   - 소스코드(고급언어) -> 컴파일(컴파일러) -> 목적코드(저급언어)
  - 인터프리터 언어
   - 소스 코드를 인터프리터에 의해 한 줄씩 실행
   - 소스 코드 전체가 저급 언어로 변환되기까지 기다릴 필요가 없음
  - 컴파일 언어 VS 인터프린터 언어
   - 컴파일 언어는 소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않지만 인터프린터 언어의 경우 소스 코드 인터프리터 중 오류가 발생하면 오류 발생 전까지의 코드는 실행 시켜줌

   - 일반적으로 인터프리터 언어는 컴파일 언어보다 느린데 그 이유는 컴파일을 통해 나온 결과물, 즉 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄 한 줄씩 저급언어로 해석하며 실행해야 하기 때문
   - 모든 프로그래밍 언어를 컴파일 언어와 인터프린터 언어로 칼로 자르듯 구분하기 보다는 ‘고급 언어가 저급 언어로 변환되는 대표적인 방법에는 컴파일 방식과 인터프리트 방식이 있다’

명령어의 구조

 - 연산코드와 오퍼랜드
  - 연산코드는 연산자, 오퍼랜드는 피연산자
  - 연산코드 : 명령어가 수행할 연산
   - ① 데이터 전송
    - MOVE : 데이터를 옮겨라
    - STPRE : 메모리에 저장하라
    - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
    - PUSH : 스택에 데이터를 저장하라
    - POP : 스택의 최상단 데이터를 가져와라
   - ② 산술/논리 연산
    - ADD/SUBTRACT/MULTIPLY/DIVIDE : 덧셈/뺄셈/곱셈/나눗셈을 수행하라
    - INCREMENT/DECREMENT : 오퍼랜드에 1을 더하라/ 오퍼랜드에 1을 빼라
    - AND/OR/NOT:AND/NOT:OR/NOT : 연산을 수행하라
    - COMPARE : 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라
   - ③ 제어 흐름 변경
    - JUMP : 특정 주소로 실행 순서를 옮겨라
    - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    - HALT : 프로그램의 실행을 멈춰라
    - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
   - ④ 입출력 제어
    - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
    - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
    - START IO : 입출력 장치를 시작하라
    - TEST IO : 입출력 장치의 상태를 확인하라
  - 오퍼랜드 : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치(주소필드)
   - 오퍼랜드가 하나도 없는 명령어 - 0-주소명령어
   - 오퍼랜드가 하나인 명령어 - 1-주소명령어
   - 오퍼랜드가 두 개인 명령어 - 2-주소명령어
   - 오퍼랜드가 세 개인 명령어 - 3-주소명령어

 - 주소 지정 방식

  - 명령어 주소 지정 방식
   - 유효 주소(effective address)
    - 연산에 사용할 데이터가 저장된 위치

   - 명령어 주소 지정 방식(addressing modes)
    - 연산에 사용할 데이터가 저장된 위치를 찾는 방법
    - 유효 주소를 찾는 방법
    - 다양한 명령어 주소 지정 방식들

   - 즉시 주소 지정 방식(immediate addressing mode)
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 가장 간단한 형태의 주소 지정 방식
    - 연산에 사용할 데이터의 크기가 작아질 수 있지만, 빠름

   - 직접 주소 지정 방식(direct addressing mode)
    - 오퍼랜드 필드에 유효 주소 직접적으로 명시
    - 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦

   - 간접 주소 지정 방식(indirect addressing mode)
    - 오퍼랜드 필드에 유효 주소의 주소를 명시
    - 앞선 주소 지정 방식들에 비해 속도가 느림

   - 레지스터 주소 지정 방식(register addressing mode)
    - 연산에 사용할 데이터가 저장된 레지스터 명시
    - 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름

   - 레지스터 간접 주소 지정 방식(register indirect addressing mode)
    - 연산에 사용할 데이터를 메모리에 저장
    - 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시1바이트(1byte)	8비트(8bit)
1킬로바이트(1kB)	1000바이트(1000byte)
1메가바이트(1MB)	1000킬로바이트(1000kB)
1기가바이트(1GB)	1000메가바이트(1000MB)
1테라바이트(1TB)	1000기가바이트(1000GB)
